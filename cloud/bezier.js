const Bezier = (function (t) { function n(i) { if (r[i]) return r[i].exports; const e = r[i] = { exports: {}, id: i, loaded: !1 }; return t[i].call(e.exports, e, e.exports, n), e.loaded = !0, e.exports; } var r = {}; return n.m = t, n.c = r, n.p = '', n(0); }([function (t, n, r) {
  t.exports = r(1);
}, function (t, n, r) {
  const i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t; }; !(function () {
    function n(t, n, r, i, e) { typeof e === 'undefined' && (e = 0.5); const o = y.projectionratio(e, t); const s = 1 - o; const u = { x: o * n.x + s * i.x, y: o * n.y + s * i.y }; const a = y.abcratio(e, t); const f = { x: r.x + (r.x - u.x) / a, y: r.y + (r.y - u.y) / a }; return { A: f, B: r, C: u }; } const e = Math.abs; const o = Math.min; const s = Math.max; const u = Math.cos; const a = Math.sin; const f = Math.acos; const c = Math.sqrt; const h = Math.PI; const x = { x: 0, y: 0, z: 0 }; var y = r(2); const p = r(3); const l = function (t) { let n = t && t.forEach ? t : [].slice.call(arguments); let r = !1; if (i(n[0]) === 'object') { r = n.length; const o = []; n.forEach((t) => { ['x', 'y', 'z'].forEach((n) => { typeof t[n] !== 'undefined' && o.push(t[n]); }); }), n = o; } let s = !1; const u = n.length; if (r) { if (r > 4) { if (arguments.length !== 1) throw new Error('Only new Bezier(point[]) is accepted for 4th and higher order curves'); s = !0; } } else if (u !== 6 && u !== 8 && u !== 9 && u !== 12 && arguments.length !== 1) throw new Error('Only new Bezier(point[]) is accepted for 4th and higher order curves'); const a = !s && (u === 9 || u === 12) || t && t[0] && typeof t[0].z !== 'undefined'; this._3d = a; for (var f = [], c = 0, h = a ? 3 : 2; c < u; c += h) { const x = { x: n[c], y: n[c + 1] }; a && (x.z = n[c + 2]), f.push(x); } this.order = f.length - 1, this.points = f; const p = ['x', 'y']; a && p.push('z'), this.dims = p, this.dimlen = p.length, (function (t) { for (let n = t.order, r = t.points, i = y.align(r, { p1: r[0], p2: r[n] }), o = 0; o < i.length; o++) if (e(i[o].y) > 1e-4) return void (t._linear = !1); t._linear = !0; }(this)), this._t1 = 0, this._t2 = 1, this.update(); }; l.fromSVG = function (t) { let n = t.match(/[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g).map(parseFloat); const r = /[cq]/.test(t); return r ? (n = n.map((t, r) => (r < 2 ? t : t + n[r % 2])), new l(n)) : new l(n); }, l.quadraticFromPoints = function (t, r, i, e) { if (typeof e === 'undefined' && (e = 0.5), e === 0) return new l(r, r, i); if (e === 1) return new l(t, r, r); const o = n(2, t, r, i, e); return new l(t, o.A, i); }, l.cubicFromPoints = function (t, r, i, e, o) { typeof e === 'undefined' && (e = 0.5); const s = n(3, t, r, i, e); typeof o === 'undefined' && (o = y.dist(r, s.C)); const u = o * (1 - e) / e; const a = y.dist(t, i); const f = (i.x - t.x) / a; const c = (i.y - t.y) / a; const h = o * f; const x = o * c; const p = u * f; const v = u * c; const d = { x: r.x - h, y: r.y - x }; const m = { x: r.x + p, y: r.y + v }; const g = s.A; const z = { x: g.x + (d.x - g.x) / (1 - e), y: g.y + (d.y - g.y) / (1 - e) }; const b = { x: g.x + (m.x - g.x) / e, y: g.y + (m.y - g.y) / e }; const _ = { x: t.x + (z.x - t.x) / e, y: t.y + (z.y - t.y) / e }; const w = { x: i.x + (b.x - i.x) / (1 - e), y: i.y + (b.y - i.y) / (1 - e) }; return new l(t, _, w, i); }; const v = function () { return y; }; l.getUtils = v, l.prototype = {
      getUtils: v,
      valueOf() { return this.toString(); },
      toString() { return y.pointsToString(this.points); },
      toSVG(t) { if (this._3d) return !1; for (var n = this.points, r = n[0].x, i = n[0].y, e = ['M', r, i, this.order === 2 ? 'Q' : 'C'], o = 1, s = n.length; o < s; o++)e.push(n[o].x), e.push(n[o].y); return e.join(' '); },
      update() { this.dpoints = []; for (let t = this.points, n = t.length, r = n - 1; n > 1; n--, r--) { for (var i, e = [], o = 0; o < r; o++)i = { x: r * (t[o + 1].x - t[o].x), y: r * (t[o + 1].y - t[o].y) }, this._3d && (i.z = r * (t[o + 1].z - t[o].z)), e.push(i); this.dpoints.push(e), t = e; } this.computedirection(); },
      computedirection() { const t = this.points; const n = y.angle(t[0], t[this.order], t[1]); this.clockwise = n > 0; },
      length() { return y.length(this.derivative.bind(this)); },
      _lut: [],
      getLUT(t) { if (t = t || 100, this._lut.length === t) return this._lut; this._lut = []; for (let n = 0; n <= t; n++) this._lut.push(this.compute(n / t)); return this._lut; },
      on(t, n) { n = n || 5; for (var r, i = this.getLUT(), e = [], o = 0, s = 0; s < i.length; s++)r = i[s], y.dist(r, t) < n && (e.push(r), o += s / i.length); return !!e.length && (o /= e.length); },
      project(t) { const n = this.getLUT(); const r = n.length - 1; const i = y.closest(n, t); let e = i.mdist; const o = i.mpos; if (o === 0 || o === r) { var s = o / r; const u = this.compute(s); return u.t = s, u.d = e, u; } let a; var s; let f; let c; const h = (o - 1) / r; const x = (o + 1) / r; const p = 0.1 / r; for (e += 1, s = h, a = s; s < x + p; s += p)f = this.compute(s), c = y.dist(t, f), c < e && (e = c, a = s); return f = this.compute(a), f.t = a, f.d = e, f; },
      get(t) { return this.compute(t); },
      point(t) { return this.points[t]; },
      compute(t) { if (t === 0) return this.points[0]; if (t === 1) return this.points[this.order]; let n = this.points; const r = 1 - t; if (this.order === 1) return f = { x: r * n[0].x + t * n[1].x, y: r * n[0].y + t * n[1].y }, this._3d && (f.z = r * n[0].z + t * n[1].z), f; if (this.order < 4) { let i; let e; let o; const s = r * r; const u = t * t; let a = 0; this.order === 2 ? (n = [n[0], n[1], n[2], x], i = s, e = r * t * 2, o = u) : this.order === 3 && (i = s * r, e = s * t * 3, o = r * u * 3, a = t * u); var f = { x: i * n[0].x + e * n[1].x + o * n[2].x + a * n[3].x, y: i * n[0].y + e * n[1].y + o * n[2].y + a * n[3].y }; return this._3d && (f.z = i * n[0].z + e * n[1].z + o * n[2].z + a * n[3].z), f; } for (var c = JSON.parse(JSON.stringify(this.points)); c.length > 1;) { for (let h = 0; h < c.length - 1; h++)c[h] = { x: c[h].x + (c[h + 1].x - c[h].x) * t, y: c[h].y + (c[h + 1].y - c[h].y) * t }, typeof c[h].z !== 'undefined' && (c[h] = c[h].z + (c[h + 1].z - c[h].z) * t); c.splice(c.length - 1, 1); } return c[0]; },
      raise() { for (var t, n, r, i = this.points, e = [i[0]], o = i.length, t = 1; t < o; t++)n = i[t], r = i[t - 1], e[t] = { x: (o - t) / o * n.x + t / o * r.x, y: (o - t) / o * n.y + t / o * r.y }; return e[o] = i[o - 1], new l(e); },
      derivative(t) { let n; let r; const i = 1 - t; let e = 0; let o = this.dpoints[0]; this.order === 2 && (o = [o[0], o[1], x], n = i, r = t), this.order === 3 && (n = i * i, r = i * t * 2, e = t * t); const s = { x: n * o[0].x + r * o[1].x + e * o[2].x, y: n * o[0].y + r * o[1].y + e * o[2].y }; return this._3d && (s.z = n * o[0].z + r * o[1].z + e * o[2].z), s; },
      inflections() { return y.inflections(this.points); },
      normal(t) { return this._3d ? this.__normal3(t) : this.__normal2(t); },
      __normal2(t) { const n = this.derivative(t); const r = c(n.x * n.x + n.y * n.y); return { x: -n.y / r, y: n.x / r }; },
      __normal3(t) { const n = this.derivative(t); const r = this.derivative(t + 0.01); const i = c(n.x * n.x + n.y * n.y + n.z * n.z); const e = c(r.x * r.x + r.y * r.y + r.z * r.z); n.x /= i, n.y /= i, n.z /= i, r.x /= e, r.y /= e, r.z /= e; const o = { x: r.y * n.z - r.z * n.y, y: r.z * n.x - r.x * n.z, z: r.x * n.y - r.y * n.x }; const s = c(o.x * o.x + o.y * o.y + o.z * o.z); o.x /= s, o.y /= s, o.z /= s; const u = [o.x * o.x, o.x * o.y - o.z, o.x * o.z + o.y, o.x * o.y + o.z, o.y * o.y, o.y * o.z - o.x, o.x * o.z - o.y, o.y * o.z + o.x, o.z * o.z]; const a = { x: u[0] * n.x + u[1] * n.y + u[2] * n.z, y: u[3] * n.x + u[4] * n.y + u[5] * n.z, z: u[6] * n.x + u[7] * n.y + u[8] * n.z }; return a; },
      hull(t) { let n; let r = this.points; let i = []; const e = []; let o = 0; let s = 0; let u = 0; for (e[o++] = r[0], e[o++] = r[1], e[o++] = r[2], this.order === 3 && (e[o++] = r[3]); r.length > 1;) { for (i = [], s = 0, u = r.length - 1; s < u; s++)n = y.lerp(t, r[s], r[s + 1]), e[o++] = n, i.push(n); r = i; } return e; },
      split(t, n) { if (t === 0 && n) return this.split(n).left; if (n === 1) return this.split(t).right; const r = this.hull(t); const i = { left: new l(this.order === 2 ? [r[0], r[3], r[5]] : [r[0], r[4], r[7], r[9]]), right: new l(this.order === 2 ? [r[5], r[4], r[2]] : [r[9], r[8], r[6], r[3]]), span: r }; if (i.left._t1 = y.map(0, 0, 1, this._t1, this._t2), i.left._t2 = y.map(t, 0, 1, this._t1, this._t2), i.right._t1 = y.map(t, 0, 1, this._t1, this._t2), i.right._t2 = y.map(1, 0, 1, this._t1, this._t2), !n) return i; n = y.map(n, t, 1, 0, 1); const e = i.right.split(n); return e.left; },
      extrema() { let t; let n; const r = this.dims; const i = {}; let e = []; return r.forEach((r) => { n = function (t) { return t[r]; }, t = this.dpoints[0].map(n), i[r] = y.droots(t), this.order === 3 && (t = this.dpoints[1].map(n), i[r] = i[r].concat(y.droots(t))), i[r] = i[r].filter((t) => t >= 0 && t <= 1), e = e.concat(i[r].sort(y.numberSort)); }), e = e.sort(y.numberSort).filter((t, n) => e.indexOf(t) === n), i.values = e, i; },
      bbox() { const t = this.extrema(); const n = {}; return this.dims.forEach((r) => { n[r] = y.getminmax(this, r, t[r]); }), n; },
      overlaps(t) { const n = this.bbox(); const r = t.bbox(); return y.bboxoverlap(n, r); },
      offset(t, n) {
        if (typeof n !== 'undefined') {
          const r = this.get(t); var i = this.normal(t); const e = {
            c: r, n: i, x: r.x + i.x * n, y: r.y + i.y * n,
          }; return this._3d && (e.z = r.z + i.z * n), e;
        } if (this._linear) { const o = this.normal(0); const s = this.points.map((n) => { const r = { x: n.x + t * o.x, y: n.y + t * o.y }; return n.z && i.z && (r.z = n.z + t * o.z), r; }); return [new l(s)]; } const u = this.reduce(); return u.map((n) => n.scale(t));
      },
      simple() { if (this.order === 3) { const t = y.angle(this.points[0], this.points[3], this.points[1]); const n = y.angle(this.points[0], this.points[3], this.points[2]); if (t > 0 && n < 0 || t < 0 && n > 0) return !1; } const r = this.normal(0); const i = this.normal(1); let o = r.x * i.x + r.y * i.y; this._3d && (o += r.z * i.z); const s = e(f(o)); return s < h / 3; },
      reduce() { let t; let n; let r = 0; let i = 0; const o = 0.01; const s = []; const u = []; let a = this.extrema().values; for (a.indexOf(0) === -1 && (a = [0].concat(a)), a.indexOf(1) === -1 && a.push(1), r = a[0], t = 1; t < a.length; t++)i = a[t], n = this.split(r, i), n._t1 = r, n._t2 = i, s.push(n), r = i; return s.forEach((t) => { for (r = 0, i = 0; i <= 1;) for (i = r + o; i <= 1 + o; i += o) if (n = t.split(r, i), !n.simple()) { if (i -= o, e(r - i) < o) return []; n = t.split(r, i), n._t1 = y.map(r, 0, 1, t._t1, t._t2), n._t2 = y.map(i, 0, 1, t._t1, t._t2), u.push(n), r = i; break; }r < 1 && (n = t.split(r, 1), n._t1 = y.map(r, 0, 1, t._t1, t._t2), n._t2 = t._t2, u.push(n)); }), u; },
      scale(t) { const n = this.order; let r = !1; if (typeof t === 'function' && (r = t), r && n === 2) return this.raise().scale(r); const i = this.clockwise; const e = r ? r(0) : t; const o = r ? r(1) : t; const s = [this.offset(0, 10), this.offset(1, 10)]; const u = y.lli4(s[0], s[0].c, s[1], s[1].c); if (!u) throw new Error('cannot scale this curve. Try reducing it first.'); const a = this.points; const f = []; return [0, 1].forEach((t) => { const r = f[t * n] = y.copy(a[t * n]); r.x += (t ? o : e) * s[t].n.x, r.y += (t ? o : e) * s[t].n.y; }), r ? ([0, 1].forEach((e) => { if (this.order !== 2 || !e) { const o = a[e + 1]; const s = { x: o.x - u.x, y: o.y - u.y }; let h = r ? r((e + 1) / n) : t; r && !i && (h = -h); const x = c(s.x * s.x + s.y * s.y); s.x /= x, s.y /= x, f[e + 1] = { x: o.x + h * s.x, y: o.y + h * s.y }; } }), new l(f)) : ([0, 1].forEach((t) => { if (this.order !== 2 || !t) { const r = f[t * n]; const i = this.derivative(t); const e = { x: r.x + i.x, y: r.y + i.y }; f[t + 1] = y.lli4(r, e, u, a[t + 1]); } }), new l(f)); },
      outline(t, n, r, i) { function e(t, n, r, i, e) { return function (o) { const s = i / r; const u = (i + e) / r; const a = n - t; return y.map(o, 0, 1, t + s * a, t + u * a); }; }n = typeof n === 'undefined' ? t : n; let o; const s = this.reduce(); const u = s.length; const a = []; let f = []; let c = 0; const h = this.length(); const x = typeof r !== 'undefined' && typeof i !== 'undefined'; s.forEach((o) => { _ = o.length(), x ? (a.push(o.scale(e(t, r, h, c, _))), f.push(o.scale(e(-n, -i, h, c, _)))) : (a.push(o.scale(t)), f.push(o.scale(-n))), c += _; }), f = f.map((t) => (o = t.points, o[3] ? t.points = [o[3], o[2], o[1], o[0]] : t.points = [o[2], o[1], o[0]], t)).reverse(); const l = a[0].points[0]; const v = a[u - 1].points[a[u - 1].points.length - 1]; const d = f[u - 1].points[f[u - 1].points.length - 1]; const m = f[0].points[0]; const g = y.makeline(d, l); const z = y.makeline(v, m); const b = [g].concat(a).concat([z]).concat(f); var _ = b.length; return new p(b); },
      outlineshapes(t, n, r) { n = n || t; for (var i = this.outline(t, n).curves, e = [], o = 1, s = i.length; o < s / 2; o++) { const u = y.makeshape(i[o], i[s - o], r); u.startcap.virtual = o > 1, u.endcap.virtual = o < s / 2 - 1, e.push(u); } return e; },
      intersects(t, n) { return t ? t.p1 && t.p2 ? this.lineIntersects(t) : (t instanceof l && (t = t.reduce()), this.curveintersects(this.reduce(), t, n)) : this.selfintersects(n); },
      lineIntersects(t) { const n = o(t.p1.x, t.p2.x); const r = o(t.p1.y, t.p2.y); const i = s(t.p1.x, t.p2.x); const e = s(t.p1.y, t.p2.y); const u = this; return y.roots(this.points, t).filter((t) => { const o = u.get(t); return y.between(o.x, n, i) && y.between(o.y, r, e); }); },
      selfintersects(t) { let n; let r; let i; let e; const o = this.reduce(); const s = o.length - 2; let u = []; for (n = 0; n < s; n++)i = o.slice(n, n + 1), e = o.slice(n + 2), r = this.curveintersects(i, e, t), u = u.concat(r); return u; },
      curveintersects(t, n, r) { const i = []; t.forEach((t) => { n.forEach((n) => { t.overlaps(n) && i.push({ left: t, right: n }); }); }); let e = []; return i.forEach((t) => { const n = y.pairiteration(t.left, t.right, r); n.length > 0 && (e = e.concat(n)); }), e; },
      arcs(t) { t = t || 0.5; const n = []; return this._iterate(t, n); },
      _error(t, n, r, i) { const o = (i - r) / 4; const s = this.get(r + o); const u = this.get(i - o); const a = y.dist(t, n); const f = y.dist(t, s); const c = y.dist(t, u); return e(f - a) + e(c - a); },
      _iterate(t, n) { let r; let i = 0; let e = 1; do { r = 0, e = 1; var o; var s; var f; var c; var h; const x = this.get(i); let p = !1; let l = !1; let v = e; let d = 1; let m = 0; do { l = p, c = f, v = (i + e) / 2, m++, o = this.get(v), s = this.get(e), f = y.getccenter(x, o, s), f.interval = { start: i, end: e }; const g = this._error(f, x, i, e); if (p = g <= t, h = l && !p, h || (d = e), p) { if (e >= 1) { if (f.interval.end = d = 1, c = f, e > 1) { const z = { x: f.x + f.r * u(f.e), y: f.y + f.r * a(f.e) }; f.e += y.angle({ x: f.x, y: f.y }, z, this.get(1)); } break; }e += (e - i) / 2; } else e = v; } while (!h && r++ < 100); if (r >= 100) break; c = c || f, n.push(c), i = d; } while (e < 1); return n; },
    }, t.exports = l;
  }());
}, function (t, n, r) {
  !(function () {
    const n = Math.abs; const i = Math.cos; const e = Math.sin; const o = Math.acos; const s = Math.atan2; const u = Math.sqrt; const a = Math.pow; const f = function (t) { return t < 0 ? -((-t) ** (1 / 3)) : t ** (1 / 3); }; const c = Math.PI; const h = 2 * c; const x = c / 2; const y = 1e-6; const p = Number.MAX_SAFE_INTEGER; const l = Number.MIN_SAFE_INTEGER; var v = {
      Tvalues: [-0.06405689286260563, 0.06405689286260563, -0.1911188674736163, 0.1911188674736163, -0.3150426796961634, 0.3150426796961634, -0.4337935076260451, 0.4337935076260451, -0.5454214713888396, 0.5454214713888396, -0.6480936519369755, 0.6480936519369755, -0.7401241915785544, 0.7401241915785544, -0.820001985973903, 0.820001985973903, -0.8864155270044011, 0.8864155270044011, -0.9382745520027328, 0.9382745520027328, -0.9747285559713095, 0.9747285559713095, -0.9951872199970213, 0.9951872199970213],
      Cvalues: [0.12793819534675216, 0.12793819534675216, 0.1258374563468283, 0.1258374563468283, 0.12167047292780339, 0.12167047292780339, 0.1155056680537256, 0.1155056680537256, 0.10744427011596563, 0.10744427011596563, 0.09761865210411388, 0.09761865210411388, 0.08619016153195327, 0.08619016153195327, 0.0733464814110803, 0.0733464814110803, 0.05929858491543678, 0.05929858491543678, 0.04427743881741981, 0.04427743881741981, 0.028531388628933663, 0.028531388628933663, 0.0123412297999872, 0.0123412297999872],
      arcfn(t, n) { const r = n(t); let i = r.x * r.x + r.y * r.y; return typeof r.z !== 'undefined' && (i += r.z * r.z), u(i); },
      between(t, n, r) { return n <= t && t <= r || v.approximately(t, n) || v.approximately(t, r); },
      approximately(t, r, i) { return n(t - r) <= (i || y); },
      length(t) { let n; let r; const i = 0.5; let e = 0; const o = v.Tvalues.length; for (n = 0; n < o; n++)r = i * v.Tvalues[n] + i, e += v.Cvalues[n] * v.arcfn(r, t); return i * e; },
      map(t, n, r, i, e) { const o = r - n; const s = e - i; const u = t - n; const a = u / o; return i + s * a; },
      lerp(t, n, r) { const i = { x: n.x + t * (r.x - n.x), y: n.y + t * (r.y - n.y) }; return n.z && r.z && (i.z = n.z + t * (r.z - n.z)), i; },
      pointToString(t) { let n = `${t.x}/${t.y}`; return typeof t.z !== 'undefined' && (n += `/${t.z}`), n; },
      pointsToString(t) { return `[${t.map(v.pointToString).join(', ')}]`; },
      copy(t) { return JSON.parse(JSON.stringify(t)); },
      angle(t, n, r) { const i = n.x - t.x; const e = n.y - t.y; const o = r.x - t.x; const u = r.y - t.y; const a = i * u - e * o; const f = i * o + e * u; return s(a, f); },
      round(t, n) { const r = `${t}`; const i = r.indexOf('.'); return parseFloat(r.substring(0, i + 1 + n)); },
      dist(t, n) { const r = t.x - n.x; const i = t.y - n.y; return u(r * r + i * i); },
      closest(t, n) { let r; let i; let e = 2 ** 63; return t.forEach((t, o) => { i = v.dist(n, t), i < e && (e = i, r = o); }), { mdist: e, mpos: r }; },
      abcratio(t, r) { if (r !== 2 && r !== 3) return !1; if (typeof t === 'undefined')t = 0.5; else if (t === 0 || t === 1) return t; const i = t ** r + (1 - t) ** r; const e = i - 1; return n(e / i); },
      projectionratio(t, n) { if (n !== 2 && n !== 3) return !1; if (typeof t === 'undefined')t = 0.5; else if (t === 0 || t === 1) return t; const r = (1 - t) ** n; const i = t ** n + r; return r / i; },
      lli8(t, n, r, i, e, o, s, u) { const a = (t * i - n * r) * (e - s) - (t - r) * (e * u - o * s); const f = (t * i - n * r) * (o - u) - (n - i) * (e * u - o * s); const c = (t - r) * (o - u) - (n - i) * (e - s); return c != 0 && { x: a / c, y: f / c }; },
      lli4(t, n, r, i) { const e = t.x; const o = t.y; const s = n.x; const u = n.y; const a = r.x; const f = r.y; const c = i.x; const h = i.y; return v.lli8(e, o, s, u, a, f, c, h); },
      lli(t, n) { return v.lli4(t, t.c, n, n.c); },
      makeline(t, n) { const i = r(1); const e = t.x; const o = t.y; const s = n.x; const u = n.y; const a = (s - e) / 3; const f = (u - o) / 3; return new i(e, o, e + a, o + f, e + 2 * a, o + 2 * f, s, u); },
      findbbox(t) {
        let n = p; let r = p; let i = l; let e = l; return t.forEach((t) => { const o = t.bbox(); n > o.x.min && (n = o.x.min), r > o.y.min && (r = o.y.min), i < o.x.max && (i = o.x.max), e < o.y.max && (e = o.y.max); }), {
          x: {
            min: n, mid: (n + i) / 2, max: i, size: i - n,
          },
          y: {
            min: r, mid: (r + e) / 2, max: e, size: e - r,
          },
        };
      },
      shapeintersections(t, n, r, i, e) { if (!v.bboxoverlap(n, i)) return []; const o = []; const s = [t.startcap, t.forward, t.back, t.endcap]; const u = [r.startcap, r.forward, r.back, r.endcap]; return s.forEach((n) => { n.virtual || u.forEach((i) => { if (!i.virtual) { const s = n.intersects(i, e); s.length > 0 && (s.c1 = n, s.c2 = i, s.s1 = t, s.s2 = r, o.push(s)); } }); }), o; },
      makeshape(t, n, r) {
        const i = n.points.length; const e = t.points.length; const o = v.makeline(n.points[i - 1], t.points[0]); const s = v.makeline(t.points[e - 1], n.points[0]); const u = {
          startcap: o, forward: t, back: n, endcap: s, bbox: v.findbbox([o, t, n, s]),
        }; const a = v; return u.intersections = function (t) { return a.shapeintersections(u, u.bbox, t, t.bbox, r); }, u;
      },
      getminmax(t, n, r) {
        if (!r) return { min: 0, max: 0 }; let i; let e; let o = p; let s = l; r.indexOf(0) === -1 && (r = [0].concat(r)), r.indexOf(1) === -1 && r.push(1); for (let u = 0, a = r.length; u < a; u++)i = r[u], e = t.get(i), e[n] < o && (o = e[n]), e[n] > s && (s = e[n]); return {
          min: o, mid: (o + s) / 2, max: s, size: s - o,
        };
      },
      align(t, n) { const r = n.p1.x; const o = n.p1.y; const u = -s(n.p2.y - o, n.p2.x - r); const a = function (t) { return { x: (t.x - r) * i(u) - (t.y - o) * e(u), y: (t.x - r) * e(u) + (t.y - o) * i(u) }; }; return t.map(a); },
      roots(t, n) { n = n || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } }; const r = t.length - 1; var e = v.align(t, n); const s = function (t) { return t >= 0 && t <= 1; }; if (r === 2) { var a = e[0].y; var c = e[1].y; var x = e[2].y; var y = a - 2 * c + x; if (y !== 0) { const p = -u(c * c - a * x); const l = -a + c; var d = -(p + l) / y; const m = -(-p + l) / y; return [d, m].filter(s); } return c !== x && y === 0 ? [(2 * c - x) / 2 * (c - x)].filter(s) : []; } let g; var d; let z; let b; let _; const w = e[0].y; const E = e[1].y; const S = e[2].y; const M = e[3].y; var y = -w + 3 * E - 3 * S + M; var a = (3 * w - 6 * E + 3 * S) / y; var c = (-3 * w + 3 * E) / y; var x = w / y; var e = (3 * c - a * a) / 3; const k = e / 3; const O = (2 * a * a * a - 9 * a * c + 27 * x) / 27; const T = O / 2; const N = T * T + k * k * k; if (N < 0) { const j = -e / 3; const I = j * j * j; const A = u(I); const C = -O / (2 * A); const F = C < -1 ? -1 : C > 1 ? 1 : C; const q = o(F); const U = f(A); const B = 2 * U; return z = B * i(q / 3) - a / 3, b = B * i((q + h) / 3) - a / 3, _ = B * i((q + 2 * h) / 3) - a / 3, [z, b, _].filter(s); } if (N === 0) return g = T < 0 ? f(-T) : -f(T), z = 2 * g - a / 3, b = -g - a / 3, [z, b].filter(s); const G = u(N); return g = f(-T + G), d = f(T + G), [g - d - a / 3].filter(s); },
      droots(t) { if (t.length === 3) { var n = t[0]; var r = t[1]; const i = t[2]; const e = n - 2 * r + i; if (e !== 0) { const o = -u(r * r - n * i); const s = -n + r; const a = -(o + s) / e; const f = -(-o + s) / e; return [a, f]; } return r !== i && e === 0 ? [(2 * r - i) / (2 * (r - i))] : []; } if (t.length === 2) { var n = t[0]; var r = t[1]; return n !== r ? [n / (n - r)] : []; } },
      inflections(t) { if (t.length < 4) return []; const n = v.align(t, { p1: t[0], p2: t.slice(-1)[0] }); const r = n[2].x * n[1].y; const i = n[3].x * n[1].y; const e = n[1].x * n[2].y; var o = n[3].x * n[2].y; const s = 18 * (-3 * r + 2 * i + 3 * e - o); const u = 18 * (3 * r - i - 3 * e); const a = 18 * (e - r); if (v.approximately(s, 0)) { if (!v.approximately(u, 0)) { const f = -a / u; if (f >= 0 && f <= 1) return [f]; } return []; } const c = u * u - 4 * s * a; const h = Math.sqrt(c); var o = 2 * s; return v.approximately(o, 0) ? [] : [(h - u) / o, -(u + h) / o].filter((t) => t >= 0 && t <= 1); },
      bboxoverlap(t, r) { let i; let e; let o; let s; let u; const a = ['x', 'y']; const f = a.length; for (i = 0; i < f; i++) if (e = a[i], o = t[e].mid, s = r[e].mid, u = (t[e].size + r[e].size) / 2, n(o - s) >= u) return !1; return !0; },
      expandbox(t, n) { n.x.min < t.x.min && (t.x.min = n.x.min), n.y.min < t.y.min && (t.y.min = n.y.min), n.z && n.z.min < t.z.min && (t.z.min = n.z.min), n.x.max > t.x.max && (t.x.max = n.x.max), n.y.max > t.y.max && (t.y.max = n.y.max), n.z && n.z.max > t.z.max && (t.z.max = n.z.max), t.x.mid = (t.x.min + t.x.max) / 2, t.y.mid = (t.y.min + t.y.max) / 2, t.z && (t.z.mid = (t.z.min + t.z.max) / 2), t.x.size = t.x.max - t.x.min, t.y.size = t.y.max - t.y.min, t.z && (t.z.size = t.z.max - t.z.min); },
      pairiteration(t, n, r) { const i = t.bbox(); const e = n.bbox(); const o = 1e5; const s = r || 0.5; if (i.x.size + i.y.size < s && e.x.size + e.y.size < s) return [`${(o * (t._t1 + t._t2) / 2 | 0) / o}/${(o * (n._t1 + n._t2) / 2 | 0) / o}`]; const u = t.split(0.5); const a = n.split(0.5); let f = [{ left: u.left, right: a.left }, { left: u.left, right: a.right }, { left: u.right, right: a.right }, { left: u.right, right: a.left }]; f = f.filter((t) => v.bboxoverlap(t.left.bbox(), t.right.bbox())); let c = []; return f.length === 0 ? c : (f.forEach((t) => { c = c.concat(v.pairiteration(t.left, t.right, s)); }), c = c.filter((t, n) => c.indexOf(t) === n)); },
      getccenter(t, n, r) { let o; const u = n.x - t.x; const a = n.y - t.y; const f = r.x - n.x; const c = r.y - n.y; const y = u * i(x) - a * e(x); const p = u * e(x) + a * i(x); const l = f * i(x) - c * e(x); const d = f * e(x) + c * i(x); const m = (t.x + n.x) / 2; const g = (t.y + n.y) / 2; const z = (n.x + r.x) / 2; const b = (n.y + r.y) / 2; const _ = m + y; const w = g + p; const E = z + l; const S = b + d; const M = v.lli8(m, g, _, w, z, b, E, S); const k = v.dist(M, t); let O = s(t.y - M.y, t.x - M.x); const T = s(n.y - M.y, n.x - M.x); let N = s(r.y - M.y, r.x - M.x); return O < N ? ((O > T || T > N) && (O += h), O > N && (o = N, N = O, O = o)) : N < T && T < O ? (o = N, N = O, O = o) : N += h, M.s = O, M.e = N, M.r = k, M; },
      numberSort(t, n) { return t - n; },
    }; t.exports = v;
  }());
}, function (t, n, r) {
  !(function () {
    const n = r(2); const i = function (t) { this.curves = [], this._3d = !1, t && (this.curves = t, this._3d = this.curves[0]._3d); }; i.prototype = {
      valueOf() { return this.toString(); }, toString() { return `[${this.curves.map((t) => n.pointsToString(t.points)).join(', ')}]`; }, addCurve(t) { this.curves.push(t), this._3d = this._3d || t._3d; }, length() { return this.curves.map((t) => t.length()).reduce((t, n) => t + n); }, curve(t) { return this.curves[t]; }, bbox: function t() { for (var r = this.curves, t = r[0].bbox(), i = 1; i < r.length; i++)n.expandbox(t, r[i].bbox()); return t; }, offset: function t(n) { let t = []; return this.curves.forEach((r) => { t = t.concat(r.offset(n)); }), new i(t); },
    }, t.exports = i;
  }());
}]));
